! ( Last modified on 23 Dec 2000 at 22:01:38 )

!  ** FOR THE CRAY 2, LINES STARTING 'CDIR$ IVDEP' TELL THE COMPILER TO
!     IGNORE POTENTIAL VECTOR DEPENDENCIES AS THEY ARE KNOWN TO BE O.K.

      SUBROUTINE DINITW( N, NG, NEL, IELING, LELING, ISTADG, LSTADG, &
                         IELVAR, LELVAR, ISTAEV, LSTAEV, INTVAR, LNTVAR, &
                         ISTADH, LSTADH, ICNA, LICNA, ISTADA, LSTADA, &
                         ITYPEE, LITYPE, &
                         GXEQX, LGXEQX, INTREP, LINTRE, LFUVAL, ALTRIV, &
                         DIRECT, FDGRAD, LFXI, LGXI, LHXI, LGGFX, &
                         LDX, LGRJAC, LQGRAD, LBREAK, LP, LXCP, &
                         LX0, LGX0, LDELTX, LBND, LWKSTR, LSPTRS, &
                         LSELTS, LINDEX, LSWKSP, LSTAGV, LSTAJC, LIUSED, &
                         LFREEC, LNNONZ, LNONZ2, LSYMMD, LSYMMH, LSLGRP, &
                         LSVGRP, LGCOLJ, LVALJR, LSEND, LNPTRS, LNELTS, &
                         LNNDEX, LNWKSP, LNSTGV, LNSTJC, LNIUSE, LNFREC, &
                         LNNNON, LNNNO2, LNSYMD, LNSYMH, LNLGRP, LNVGRP, &
                         LNGCLJ, LNVLJR, LNQGRD, LNBRAK, LNP, LNBND, &
                         LNFXI, LNGXI, LNGUVL, LNHXI, LNHUVL, LNGGFX, &
                         LNDX, LNGRJC, LIWK2, LWK2, MAXSIN, NINVAR, &
                         NTYPE, NSETS, MAXSEL, LSTYPE, LSSWTR, LSSIWT, &
                         LSIWTR, LSWTRA, LNTYPE, LNSWTR, LNSIWT, LNIWTR, &
                         LNWTRA, LSISET, LSSVSE, LNISET, LNSVSE, RANGE, &
                         IWK, LIWK, WK,  LWK, IPRINT, IOUT, INFORM)
      INTEGER, PARAMETER :: wp = KIND( 1.0D+0 )

! --------------------------------------------------------------------

!  COMPUTE THE STARTING ADDRESSES FOR THE PARTITIONS OF THE WORKSPACE
!  ARRAYS FUVALS, IWK AND WK. ALSO FILL RELEVANT PORTIONS OF IWK.
!  THE ADDRESSES FOR IWK AND WK ARE DESCRIBED HERE; THOSE FOR FUVALS
!  ARE DESCRIBED IN THE INTRODUCTORY COMMENTS TO SUBROUTINE SBMIN.

!  NICK GOULD, 20TH JUNE 1990.
!  FOR CGT PRODUCTIONS.

! --------------------------------------------------------------------

      INTEGER :: N, NG, NEL, INFORM, LITYPE, LWK, LIWK
      INTEGER :: LFUVAL, LELVAR, LSTAEV, LSTADH, LELING, LNTVAR
      INTEGER :: LGXEQX, LSTADG, LICNA, LSTADA, IOUT, IPRINT
      INTEGER :: LFXI, LGXI, LHXI, LGGFX, LDX, LGRJAC
      INTEGER :: LQGRAD, LBREAK, LP, LXCP, LBND, LWKSTR
      INTEGER :: LGX0, LDELTX, LSPTRS, LSELTS, LINDEX, LX0
      INTEGER :: LSWKSP, LSTAGV, LSTAJC, LIUSED, LFREEC, LINTRE
      INTEGER :: LNNONZ, LNONZ2, LSYMMD, LSYMMH, LSISET, LSSVSE
      INTEGER :: LSLGRP, LSVGRP, LGCOLJ, LVALJR, LSEND
      INTEGER :: LNPTRS, LNELTS, LNNDEX, LNWKSP, LNSTGV, LNSTJC
      INTEGER :: LNIUSE, LNNNON, LNNNO2, LNSYMD, LNSYMH, LNLGRP
      INTEGER :: LNVGRP, LNGCLJ, LNVLJR, LNFREC, LNISET, LNSVSE
      INTEGER :: LNQGRD, LNBRAK, LNP, LNBND,  LNFXI, LNGXI
      INTEGER :: LNGUVL, LNHXI, LNHUVL, LNGGFX, LNDX, LNGRJC
      INTEGER :: LIWK2, LWK2, NINVAR, MAXSEL, MAXSIN, NTYPE
      INTEGER :: LSTYPE, LSSWTR, LSSIWT, LSIWTR, LSWTRA, NSETS
      INTEGER :: LNTYPE, LNSWTR, LNSIWT, LNIWTR, LNWTRA
      EXTERNAL :: RANGE 
      LOGICAL :: DIRECT, ALTRIV, FDGRAD
      INTEGER :: IELVAR( LELVAR ), ISTAEV( LSTAEV )
      INTEGER :: ISTADH( LSTADH ), IWK ( LIWK )
      INTEGER :: INTVAR( LNTVAR ), ISTADG( LSTADG )
      INTEGER :: ICNA ( LICNA ), ISTADA( LSTADA )
      INTEGER :: IELING( LELING ), ITYPEE( LITYPE )
      REAL ( KIND = wp ) :: WK ( LWK )
      LOGICAL :: GXEQX ( LGXEQX ), INTREP( LINTRE )

!  LOCAL VARIABLES.

      INTEGER :: I, J, K, L, NVARGP, IIELTS, IENTRY, IG, IS
      INTEGER :: LEND, NSIZEH, NEL1, NGEL, NG1, IEL
      INTEGER :: LWFREE, LIWFRE, NELVR, LW1, LIWFRO, LWFREO
      INTEGER :: IELL, ITYPE, ISOFAR, ISTARJ, IVARP1, IVAR
      INTEGER :: JSET, INEXT, NEWVAR, NEWSET, IPT, ISTRT
      INTEGER :: NINVR, II, JJ, KK, LL
      LOGICAL :: NONTRV, ALLLIN, VRUSED
      REAL ( KIND = wp ) :: ZERO, ONE
      PARAMETER ( ZERO = 0.0_wp, ONE = 1.0_wp )

!  EXTERNAL SUBROUTINES AND FUNCTIONS USED.

!D    EXTERNAL         DSYMMH

!  INTRINSIC FUNCTIONS.

      INTRINSIC        MAX

!  SET CONSTANTS.

      NEL1 = NEL + 1
      NG1 = NG + 1
      NGEL = ISTADG( NG1 ) - 1
      ALLLIN = NEL == 0

!  SET UP INTVAR, THE STARTING ADDRESSES FOR THE ELEMENT GRADIENTS
!  WITH RESPECT TO THEIR INTERNAL VARIABLES. ALSO COMPUTE MAXSIN,
!  THE MAXIMUM NUMBER OF INTERNAL VARIABLES IN AN ELEMENT.

      IF ( .NOT. ALLLIN ) THEN
         K = INTVAR( 1 )
         MAXSIN = K
         INTVAR( 1 ) = NEL1
         DO 10 IEL = 2, NEL
            L = INTVAR( IEL )
            INTVAR( IEL ) = INTVAR( IEL - 1 ) + K
            K = L
            MAXSIN = MAX( MAXSIN, K )
   10    CONTINUE
         INTVAR( NEL1 ) = INTVAR( NEL ) + K
      ELSE
         INTVAR( 1 ) = 1
         MAXSIN = 0
      END IF

!  COMPUTE THE TOTAL NUMBER OF INTERNAL VARIABLES.

      NINVAR = INTVAR( NEL1 ) - INTVAR( 1 )

!  CALCULATE THE LENGTH, IIELTS, OF WORKSPACE REQUIRED TO
!  DETERMINE WHICH ELEMENTS USE EACH OF THE VARIABLES.
!  ALSO FIND THE MAXIMUM NUMBER OF VARIABLES IN AN ELEMENT, MAXSEL.
!  THIS IS A DUMMY RUN FOR LOOP 130 MERELY TO CALCULATE THE
!  SPACE REQUIRED.

      IF ( LIWK < N ) THEN
         WRITE( IOUT, 2030 ) N - LIWK
         INFORM = 4
         RETURN
      END IF

!  IWK( I ) WILL BE USED AS A LIST OF LINKS CHAINING THE ELEMENTS USING
!  VARIABLE I. IF IWK( I ) IS NEGATIVE, THE LIST IS EMPTY.

!DIR$ IVDEP
      DO 20 I = 1, N
         IWK( I ) = - 1
   20 CONTINUE
      IIELTS = N
      MAXSEL = 0
      IF ( .NOT. ALLLIN ) THEN

!  LOOP OVER THE GROUP, CONSIDERING EACH NONLINEAR ELEMENT IN TURN.

         DO 50 I = 1, NGEL
            IEL = IELING( I )
            MAXSEL = MAX( MAXSEL, ISTAEV( IEL + 1 ) - ISTAEV( IEL ) )

!  LOOP ON THE VARIABLES FROM THE I-TH ELEMENT.

            DO 40 K = ISTAEV( IEL ), ISTAEV( IEL + 1 ) - 1
               IENTRY = IELVAR( K )
               IF ( IWK( IENTRY ) >= 0 ) THEN

!  IF WE HAVE REACHED THE END OF THE LIST OF THE ELEMENTS USING
!  THE VARIABLE IELVAR( K ), ADD THE IEL-TH ELEMENT TO IT.
!  OTHERWISE, FIND THE NEXT ENTRY IN THE LIST.

   30             CONTINUE
                  IF ( IWK( IENTRY ) > 0 ) THEN
                     IENTRY = IWK( IENTRY )
                     GO TO 30
                  ELSE
                     IIELTS = IIELTS + 1
                     IF ( IIELTS > LIWK ) THEN
                        WRITE( IOUT, 2030 ) IIELTS - LIWK
                        INFORM = 4
                        RETURN
                     END IF
                     IWK( IENTRY ) = IIELTS
                     IWK( IIELTS ) = 0
                  END IF
               ELSE

!  THE LIST OF ELEMENTS INVOLVING THE VARIABLE IELVAR( K ) WAS
!  PREVIOUSLY EMPTY. INDICATE THAT THE LIST HAS NOW BEEN STARTED AND
!  THAT ITS END HAS BEEN REACHED.

                  IWK( IENTRY ) = 0
               END IF
   40       CONTINUE
   50    CONTINUE
      END IF

! -- CALCULATE THE STARTING ADDRESSES FOR THE INTEGER WORKSPACE. --

!  IWK( LSPTRS + J ), J = 1, ..., IIELTS,  WILL CONTAIN THE LINKS FOR
!  THE LISTS OF NONLINEAR ELEMENTS WHICH USE EACH VARIABLE.

      LSPTRS = 0

!  IWK( LSELTS + J ), J = 1, ..., IIELTS, WILL CONTAIN THE LISTS OF
!  NONLINEAR ELEMENTS CORRESPONDING TO THE PREVIOUSLY MENTIONED LINKS.

      LSELTS = LSPTRS + IIELTS

!  IWK( LINDEX + J ), J = 1, ..., N, WILL CONTAIN THE STATUS OF THE
!  J-TH VARIABLE AS THE CURRENT ITERATION PROGRESSES. POSSIBLE VALUES
!  ARE 0 IF THE VARIABLE LIES AWAY FROM ITS BOUNDS, 1 AND 2 IF IT LIES
!  ON ITS LOWER OR UPPER BOUNDS (RESPECTIVELY) - THESE MAY BE PROBLEM
!  BOUNDS OR TRUST REGION BOUNDS, AND 3 IF THE VARIABLE IS FIXED.

      LINDEX = LSELTS + IIELTS

!  IWK( LSWKSP + J ), J = 1, ..., MAX( NGEL, NEL, N + N ), IS USED FOR
!  WORKSPACE BY THE MATRIX-VECTOR PRODUCT SUBROUTINE HESPRD.

      LSWKSP = LINDEX + N

!  IWK( LIUSED + J ), J = 1, ..., MAX( N, NG ) WILL BE USED AS
!  WORKSPACE BY THE MATRIX-VECTOR PRODUCT SUBROUTINE HESPRD.

      IF ( DIRECT ) THEN
         LIUSED = LSWKSP + MAX( NGEL, NEL, N + N )
      ELSE
         LIUSED = LSWKSP + MAX( NGEL, NEL, N )
      END IF

!  IWK( LFREED + J ), J = 1, ..., NFREEC WILL GIVE THE INDICES OF THE
!  VARIABLES WHICH ARE CONSIDERED TO BE FREE FROM THEIR BOUNDS AT THE
!  CURRENT GENERALIZED CAUCHY POINT.

      LFREEC = LIUSED + MAX( N, NG )

!  IWK( LNNONZ + J ), J = 1, ..., NNNONZ WILL GIVE THE INDICES OF THE
!  NONZEROS IN THE VECTOR OBTAINED AS A RESULT OF THE MATRIX-VECTOR
!  PRODUCT FROM SUBROUTINE HESPRD.

      LNNONZ = LFREEC + N

!  IWK( LNONZ2 + J ), J = 1, ..., NG, WILL BE USED AS FURTHER
!  WORKSPACE BY THE MATRIX-VECTOR PRODUCT SUBROUTINE HESPRD.

      LNONZ2 = LNNONZ + N

!  IWK( LSYMMD + J ), J = 1, ..., MAXSIN, WILL GIVE THE LOCATION OF
!  THE J-TH DIAGONAL OF A MAXSIN BY MAXSIN SYMMETRIC MATRIX IN AN
!  UPPER TRIANGULAR STORAGE SCHEME.

      LSYMMD = LNONZ2 + NG

!  IWK( LSYMMH + ( I - 1 ) * MAXSIN + J ), I, J = 1, ..., MAXSIN,
!  WILL GIVE THE LOCATION OF THE (I,J)-TH ENTRY OF A MAXSIN BY
!  MAXSIN SYMMETRIC MATRIX IN AN UPPER TRIANGULAR STORAGE SCHEME.

      LSYMMH = LSYMMD + MAXSIN

!  IWK( LSLGRP + J ), J = 1, ..., NGEL, WILL CONTAIN THE NUMBER OF
!  THE GROUP WHICH USES NONLINEAR ELEMENT J.

      LSLGRP = LSYMMH + MAXSIN * MAXSIN

!  IWK( LSTAJC + J ), J = 1, ..., N, WILL CONTAIN THE STARTING
!  ADDRESSES FOR THE LIST OF NONTRIVIAL GROUP  WHICH USE THE
!  J-TH VARIABLE. IWK( LSTAJC + N + 1 ) WILL POINT TO THE FIRST FREE
!  LOCATION IN IWK AFTER THE LIST OF NONTRIVIAL GROUP  FOR THE
!  N-TH VARIABLE.

      LSTAJC = LSLGRP + NGEL

!  IWK( LSTAGV + J ), J = 1, ..., NG, WILL CONTAIN THE STARTING
!  ADDRESSES FOR THE LIST OF VARIABLES WHICH OCCUR IN THE J-TH GROUP.
!  IWK( LSTAGV + NG + 1 ) WILL POINT TO THE FIRST FREE LOCATION
!  IN IWK AFTER THE LIST OF VARIABLES FOR THE NG-TH GROUP.

      LSTAGV = LSTAJC + N + 1

!  IWK( LSVGRP + J ), J = 1, ..., NVARGP, WILL CONTAIN THE INDICES OF
!  THE VARIABLES WHICH ARE USED BY EACH GROUP IN TURN. THOSE FOR GROUP I
!  OCCUR IN LOCATIONS IWK( LSTAGV + I ) TO IWK( LSTAGV + I + 1 ) - 1.

      LSVGRP = LSTAGV + NG + 1

!  CHECK THAT THERE IS SUFFICIENT WORKSPACE.

      IF ( LSVGRP > LIWK ) THEN
         WRITE( IOUT, 2030 ) LSVGRP - LIWK
         INFORM = 4
         RETURN
      END IF

!  IWK( LGCOLJ + J ), J = 1, ..., NVARGP, WILL CONTAIN THE INDICES OF
!  THE NONTRIVIAL GROUP  WHICH USE EACH VARIABLE IN TURN. THOSE FOR
!  VARIABLE I OCCUR IN LOCATIONS IWK( LSTAJC + I ) TO
!  IWK( LSTAJC + I + 1 ) - 1.

      LGCOLJ = LSVGRP + 1

!  DETERMINE WHICH ELEMENTS USE EACH VARIABLE. INITIALIZATION.

      IF ( .NOT. ALLLIN ) THEN

!  IWK( I ) WILL BE USED AS A LIST OF LINKS CHAINING THE ELEMENTS USING
!  VARIABLE I. IF IWK( I ) IS NEGATIVE, THE LIST IS EMPTY.

!DIR$ IVDEP
         DO 100 I = 1, N
            IWK( I ) = - 1
  100    CONTINUE
         IIELTS = N

!  LOOP OVER THE GROUP, CONSIDERING EACH NONLINEAR ELEMENT IN TURN.

         DO 130 I = 1, NGEL
            IEL = IELING( I )

!  LOOP ON THE VARIABLES OF THE I-TH ELEMENT.

            DO 120 K = ISTAEV( IEL ), ISTAEV( IEL + 1 ) - 1
               IENTRY = IELVAR( K )
               IF ( IWK( IENTRY ) >= 0 ) THEN

!  IF WE HAVE REACHED THE END OF THE LIST OF THE ELEMENTS USING
!  THE VARIABLE IELVAR( K ), ADD THE I-TH ELEMENT TO IT AND
!  RECORD THAT THE END OF THE LIST HAS OCCURED.
!  OTHERWISE, FIND THE NEXT ENTRY IN THE LIST.

  110             CONTINUE
                  IF ( IWK( IENTRY ) > 0 ) THEN
                     IENTRY = IWK( IENTRY )
                     GO TO 110
                  ELSE
                     IIELTS = IIELTS + 1
                     IWK( IENTRY ) = IIELTS
                     IWK( LSELTS + IIELTS ) = I
!                    IWK( LSELTS + IIELTS ) = IEL
                     IWK( IIELTS ) = 0
                  END IF
               ELSE

!  THE LIST OF ELEMENTS INVOLVING THE VARIABLE IELVAR( K ) WAS
!  PREVIOUSLY EMPTY. INDICATE THAT THE LIST HAS NOW BEEN STARTED,
!  RECORD THE ELEMENT WHICH CONTAINS THE VARIABLE AND INDICATE
!  THAT THE END OF THE LIST HAS BEEN REACHED.

                  IWK( LSELTS + IENTRY ) = I
!                 IWK( LSELTS + IENTRY ) = IEL
                  IWK( IENTRY ) = 0
               END IF
  120       CONTINUE
  130    CONTINUE
      END IF

!  SET UP SYMMETRIC ADDRESSES FOR THE UPPER TRIANGULAR STORAGE
!  SCHEMES FOR THE ELEMENT HESSIANS.

      IF ( MAXSIN > 0 ) CALL DSYMMH ( MAXSIN, IWK( LSYMMH + 1 ), &
                                        IWK( LSYMMD + 1 ) )

!  SET UP THE STARTING ADDRESSES FOR THE ELEMENT HESSIANS
!  WITH RESPECT TO THEIR INTERNAL VARIABLES AND A POINTER BEYOND
!  THE END OF THE SPACE REQUIRED FOR THE HESSIANS.

      LGGFX = INTVAR( NEL1 )
      IF ( .NOT. ALLLIN ) THEN
         DO 140 I = 1, NEL
            ISTADH( I ) = LGGFX
            NSIZEH = INTVAR( I + 1 ) - INTVAR( I )
            LGGFX = LGGFX + NSIZEH * ( NSIZEH + 1 ) / 2
  140    CONTINUE
      END IF
      ISTADH( NEL1 ) = LGGFX

! -- CALCULATE THE STARTING ADDRESSES FOR THE REAL WORKSPACE. --

!  WK( LQGRAD + J ), J = 1, ..., N, WILL CONTAIN THE GRADIENT OF
!  THE QUADRATIC MODEL AT THE CURRENT ESTIMATE OF THE MINIMIZER.

      LQGRAD = MAX( MAX( NG, MAXSEL ) + 2 * MAXSIN, &
                    N + NINVAR + MAX( MAXSEL, NINVAR ) )

!  WK( LBREAK + J ), J = 1, ..., N, WILL CONTAIN THE BREAKPOINTS
!  ALONG THE CAUCHY ARC FROM THE CURRENT ESTIMATE OF THE MINIMIZER.

      LBREAK = LQGRAD + N

!  WK( LP + J ), J = 1, ..., N, WILL CONTAIN THE VECTOR REQUIRED
!  BY THE MATRIX-VECTOR PRODUCT SUBROUTINE HESPRD.

      LP = LBREAK + N

!  WK( LXCP + J ), J = 1, ..., N, WILL CONTAIN THE CURRENT
! (APPROXIMATE) CAUCHY POINT.

      LXCP = LP + N

!  WK( LX0 + J ), J = 1, ..., N, WILL CONTAIN THE CURRENT
!  START OF THE CAUCHY SEARCH. THIS FEATURE IS ONLY USED IF
!  MORE THAN ONE CYCLE IS USED TO SOLVE THE BQP ACCURATELY.

      LX0 = LXCP + N

!  WK( LGX0 + J ), J = 1, ..., N, WILL CONTAIN THE GRADIENT AT THE
!  CURRENT START OF THE CAUCHY SEARCH. THIS FEATURE IS ONLY USED IF
!  MORE THAN ONE CYCLE IS USED TO SOLVE THE BQP ACCURATELY.

      LGX0 = LX0 + N

!  WK( LDELTX + J ), J = 1, ..., N, WILL CONTAIN THE STEP TAKEN
!  DURING A SINGLE CYCLE, IF MORE THAN ONE CYCLE IS USED TO SOLVE
!  THE BQP ACCURATELY.

      LDELTX = LGX0 + N

!  WK( LBND + 2 * ( J - 1 ) + I ), J = 1, ..., N, I = 1, 2, WILL
!  CONTAIN THE CURRENT LOWER (I=1) AND UPPER (I=2) BOUNDS ON THE
!  VARIABLES DEFINED BY THE INTERSECTION OF THE TRUST REGION WITH
!  THE FEASIBLE BOX.

      LBND = LDELTX + N

!  WK( LWKSTR + J ), J = 1, ..., LWK2, IS THE REMAINING REAL
!  WORKSPACE WHICH IS FREE FOR OTHER PURPOSES, SUCH AS FOR FORMING
!  THE FACTORIZATION OF THE MODEL HESSIAN, IF REQUIRED.

      LWKSTR = LBND + N + N
      LWK2 = LWK - LWKSTR

!  CHECK THAT THERE IS SUFFICIENT REAL WORKSPACE.

      IF ( LWKSTR > LWK ) THEN
         INFORM = 5
         WRITE( IOUT, 2040 ) LWKSTR - LWK
         RETURN
      END IF

!  SET THE LENGTH OF EACH PARTITION OF THE REAL WORKSPACE ARRAY
!  FUVALS FOR ARRAY BOUND CHECKING IN CALLS TO OTHER SUBPROGRAMS.

      LNQGRD = LBREAK - LQGRAD
      LNBRAK = LP - LBREAK
      LNP = LXCP - LP
      LNBND = LWKSTR - LBND

!  STORE THE INDICES OF VARIABLES WHICH APPEARS IN EACH GROUP
!  AND HOW MANY GROUP  USE EACH VARIABLE. START BY INITIALIZING
!  COUNTING ARRAYS TO ZERO.

!DIR$ IVDEP
      DO 150 J = 1, N
         IWK( LSWKSP + J ) = 0
         IWK( LSTAJC + J + 1 ) = 0
  150 CONTINUE

!  ALTRIV SPECIFIES WHETHER ALL THE GROUP  ARE TRIVIAL.

      ALTRIV = .TRUE.

!  COUNT THE TOTAL NUMBER OF VARIABLES IN ALL THE GROUP, NVARGP.

      NVARGP = 0
      IWK( LSTAGV + 1 ) = 1

!  LOOP OVER THE GROUP . SEE IF THE IG-TH GROUP IS TRIVIAL.

      DO 200 IG = 1, NG
         NONTRV = .NOT. GXEQX( IG )

!  CHECK TO SEE IF ALL OF THE GROUP  ARE TRIVIAL.

         IF ( NONTRV ) ALTRIV = .FALSE.

!  LOOP OVER THE NONLINEAR ELEMENTS FROM THE IG-TH GROUP.

         DO 170 K = ISTADG( IG ), ISTADG( IG + 1 ) - 1
            IEL = IELING( K )

!  RUN THROUGH ALL THE ELEMENTAL VARIABLES CHANGING THE I-TH ENTRY OF
!  IWK( LSWKSP ) FROM ZERO TO ONE IF VARIABLE I APPEARS IN AN ELEMENT.

            DO 160 J = ISTAEV( IEL ), ISTAEV( IEL + 1 ) - 1
               I = IELVAR( J )
               IF ( IWK( LSWKSP + I ) == 0 ) THEN
                  IWK( LSWKSP + I ) = 1

!  IF THERE IS SUFFICIENT ROOM, RECORD THE NONLINEAR VARIABLES FROM
!  THE IG-TH GROUP.

                  IF ( LGCOLJ > LIWK ) THEN
                     WRITE( IOUT, 2030 ) LGCOLJ - LIWK
                     INFORM = 4
                     RETURN
                  END IF
                  IWK( LGCOLJ ) = I
                  LGCOLJ = LGCOLJ + 1
                  NVARGP = NVARGP + 1
               END IF
  160       CONTINUE

!  RECORD THAT NONLINEAR ELEMENT K OCCURS IN GROUP IELGRP(IEL).

            IWK( LSLGRP + K ) = IG
  170    CONTINUE

!  CONSIDER VARIABLES WHICH ARISE FROM THE LINEAR ELEMENT.

         DO 180 J = ISTADA( IG ), ISTADA( IG + 1 ) - 1
            I = ICNA( J )
            IF ( IWK( LSWKSP + I ) == 0 ) THEN
               IWK( LSWKSP + I ) = 1

!  IF THERE IS SUFFICIENT ROOM, RECORD THE LINEAR VARIABLES FROM
!  THE IG-TH GROUP.

               IF ( LGCOLJ > LIWK ) THEN
                  WRITE( IOUT, 2030 ) LGCOLJ - LIWK
                  INFORM = 4
                  RETURN
               END IF
               IWK( LGCOLJ ) = I
               LGCOLJ = LGCOLJ + 1
               NVARGP = NVARGP + 1
            END IF
  180    CONTINUE

!  RESET THE STATUS ARRAY IWK( LSWKSP ) TO ZERO.

         DO 190 J = IWK( LSTAGV + IG ), NVARGP
            L = IWK( LSVGRP + J )
            IWK( LSWKSP + L ) = 0

!  RECORD THAT ONE FURTHER NONTRIVIAL GROUP USES VARIABLE L.

            IF ( NONTRV ) IWK( LSTAJC + L + 1 ) = &
                          IWK( LSTAJC + L + 1 ) + 1
  190    CONTINUE

!  RECORD THE STARTING ADDRESS OF THE VARIABLES IN THE NEXT GROUP.

         IWK( LSTAGV + IG + 1 ) = NVARGP + 1
  200 CONTINUE

! -- CONTINUE SETTING STARTING ADDRESSES FOR PARTITIONS OF IWK. --

!  IWK( LVALJR + J ), J = 1, ..., NVARGP, WILL CONTAIN THE POSITIONS IN
!  FUVALS (RELATIVE TO THE STARTING ADDRESS LGRJAC) OF THE NONZEROS OF
!  THE JACOBIAN OF THE GROUP  CORRESPONDING TO THE VARIABLES AS ORDERED
!  IN IWK( LSVGRP + J ).

      LVALJR = LGCOLJ + NVARGP

!  LSEND GIVES THE TOTAL FIXED AMOUNT OF INTEGER WORKSPACE USED. LIWK2
!  GIVES THE AMOUNT OF WORKSPACE WHICH IS FREE FOR OTHER PURPOSES, SUCH
!  AS FOR FORMING THE FACTORIZATION OF THE MODEL HESSIAN, IF REQUIRED.

      LSEND = LVALJR + NVARGP

!  CHECK THAT THERE IS SUFFICIENT INTEGER WORKSPACE.

      IF ( LSEND > LIWK ) THEN
         WRITE( IOUT, 2030 ) LSEND - LIWK
         INFORM = 4
         RETURN
      END IF

!  SET THE LENGTH OF EACH PARTITION OF THE INTEGER WORKSPACE FOR
!  ARRAY BOUND CHECKING IN CALLS TO OTHER SUBPROGRAMS.

      LNPTRS = MAX( 1, LSELTS - LSPTRS )
      LNELTS = MAX( 1, LINDEX - LSELTS )
      LNNDEX = MAX( 1, LSWKSP - LINDEX )
      LNWKSP = MAX( 1, LIUSED - LSWKSP )
      LNIUSE = MAX( 1, LFREEC - LIUSED )
      LNFREC = MAX( 1, LNNONZ - LFREEC )
      LNNNON = MAX( 1, LNONZ2 - LNNONZ )
      LNNNO2 = MAX( 1, LSYMMD - LNONZ2 )
      LNSYMD = MAX( 1, LSYMMH - LSYMMD )
      LNSYMH = MAX( 1, LSLGRP - LSYMMH )
      LNLGRP = MAX( 1, LSTAJC - LSLGRP )
      LNSTJC = MAX( 1, LSTAGV - LSTAJC )
      LNSTGV = MAX( 1, LSVGRP - LSTAGV )
      LNVGRP = MAX( 1, LGCOLJ - LSVGRP )
      LNGCLJ = MAX( 1, LVALJR - LGCOLJ )
      LNVLJR = MAX( 1, LSEND - LVALJR )

!  SET THE STARTING ADDRESSES FOR THE LISTS OF NONTRIVIAL GROUP 
!  WHICH USE EACH VARIABLE IN TURN.

      K = LSTAJC + 1
      IWK( K ) = 1
      DO 210 I = 2, N + 1
         K = K + 1
         IWK( K ) = IWK( K ) + IWK( K - 1 )
  210 CONTINUE

!  CONSIDER THE IG-TH GROUP IN ORDER TO ASSOCIATE VARIABLES WITH GROUP .

      DO 230 IG = 1, NG
         IF ( .NOT. GXEQX( IG ) ) THEN
            DO 220 I = IWK( LSTAGV + IG ), IWK( LSTAGV + IG + 1 ) - 1
                L = LSTAJC + IWK( LSVGRP + I )

!  RECORD THAT GROUP IG USES VARIABLE IWK( LSVGRP + I ).

               J = IWK( L )
               IWK( LGCOLJ + J ) = IG

!  STORE THE LOCATIONS IN THE JACOBIAN OF THE GROUP  OF THE NONZEROS
!  CORRESPONDING TO EACH VARIABLE IN THE IG-TH GROUP. INCREMENT THE
!  STARTING ADDRESS FOR THE POINTER TO THE NEXT GROUP USING VARIABLE
!  IWK( LSVGRP + I ).

               IWK( LVALJR + I ) = J
               IWK( L ) = J + 1
  220      CONTINUE
         END IF
  230 CONTINUE

!  RESET THE STARTING ADDRESSES FOR THE LISTS OF GROUP  USING
!  EACH VARIABLE.

      DO 240 I = N, 2, - 1
         L = LSTAJC + I
         IWK( L ) = IWK( L - 1 )
  240 CONTINUE
      IWK( LSTAJC + 1 ) = 1

!  INITIALIZE WORKSPACE VALUES FOR SUBROUTINE HESPRD.

!DIR$ IVDEP
      DO 250 J = 1, MAX( N, NG )
         IWK( LIUSED + J ) = 0
  250 CONTINUE

!  DEFINE FURTHER PARTITIONS OF THE WORKSPACE WHENEVER FINITE-
! -DIFFERENCE GRADIENTS ARE USED.

      IF (  FDGRAD ) THEN

! -- CONTINUE SETTING STARTING ADDRESSES FOR PARTITIONS OF IWK. --

!  THE RANGE TRANSFORMATION FOR EACH NONLINEAR ELEMENT IS OF A GIVEN
!  TYPE. SUPPOSE THERE ARE NTYPE NON-TRIVIAL TYPES. IWK( LSTYPE + I )
!  GIVES THE TYPE OF NONLINEAR ELEMENT I FOR I = 1, ...., NEL.

         LSTYPE = LSEND

!  THE RANGE TRANSFORMATION FROM ELEMENTAL TO INTERNAL VARIABLES IS
!  DEFINED BY A MATRIX W. FOR EACH NON-TRIVIAL TRANSFORMATION, THE
!  MATRIX W IS RECORDED. THE INFORMATION FOR THE I-TH TYPE STARTS IN
!  LOCATION LSWTRA + IWK( LSSWTR + I ), I = 1, ...., NTYPE.

         LSSWTR = LSTYPE + NEL

!  FOR EACH TYPE OF NONLINEAR ELEMENT USING A NONTRIVIAL RANGE
!  TRANSFORMATION, INTEGER INFORMATION ISD ALSO RECORDED.
!  THE INFORMATION FOR THE I-TH TYPE STARTS IN LOCATION
!  LSIWTR + IWK( LSSIWT + I ), I = 1, ...., NTYPE.

         LSSIWT = LSSWTR + NEL

!  THE FOLLOWING PIECES OF INTEGER INFORMATION ARE RECORDED ABOUT
!  THE I-TH TYPE OF NONLINEAR ELEMENT:

!    IWK( LSIWTR + IWK( LSSIWT + I ) + 1 ):
!            THE NUMBER OF INTERNAL VARIABLES, NINVR.
!    IWK( LSIWTR + IWK( LSSIWT + I ) + 2 ):
!            THE NUMBER OF ELEMENTAL VARIABLES, NELVR.
!    IWK( LSIWTR + IWK( LSSIWT + I ) + 2 + I ),
!         I = 1, ..., NELVR + NINVR:
!            PIVOT SEQUENCES FOR THE LU FACTORS OF W.

!  AFTER THE FACTORIZATION AND COMPRESSION, ONLY NINVR LINEARLY
!  INDEPENDENT COLUMNS OF W ARE STORED.

         LSIWTR = LSSIWT + NEL
         IF ( LIWK < LSIWTR ) THEN
            WRITE( IOUT, 2030 ) LSIWTR - LIWK
            INFORM = 4
            RETURN
         END IF

! -- CONTINUE SETTING STARTING ADDRESSES FOR PARTITIONS OF WK. --

!  THE FOLLOWING PIECES OF INTEGER INFORMATION ARE RECORDED ABOUT
!  THE I-TH TYPE OF NONLINEAR ELEMENT:

!    IWK( LSWTRA + IWK( LSSWTR + I ) + I ),
!         I = 1, ..., NELVR * NINVR:  THE MATRIX W STORED BY COLUMNS.

!  AFTER THE FACTORIZATION AND COMPRESSION, ONLY NINVR LINEARLY
!  INDEPENDENT COLUMNS OF W ARE STORED.

         LSWTRA = LWKSTR

! ---------------------------------------------------------------------
!  CONSIDER ONLY ELEMENTS WHICH USE INTERNAL VARIABLES.
! ---------------------------------------------------------------------

         NTYPE = 0
         LWFREE = 1
         LIWFRE = 1

!  LOOP OVER ALL NONLINEAR ELEMENTS.

         DO 350 IEL = 1, NEL
            IF ( INTREP( IEL ) ) THEN

!  CALCULATE THE RANGE TRANSFORMATION MATRIX W.

               IS = ISTAEV( IEL )
               NINVR = INTVAR( IEL + 1 ) - INTVAR( IEL )
               NELVR = ISTAEV( IEL + 1 ) - IS
               LW1 = LWFREE + NINVR * NELVR - 1
               L = LSWTRA + LW1
!DIR$ IVDEP
               DO 280 I = 1, NELVR
                  WK( L + I ) = ZERO
  280          CONTINUE
               K = LSWTRA + LWFREE
               IS = IS - 1
               DO 320 I = 1, NELVR
                  WK( L + I ) = ONE
                  CALL RANGE ( IEL, .FALSE., WK( L + 1 ), &
                               WK( K ), NELVR, NINVR,  &
                               ITYPEE( IEL ), NELVR, NINVR )
                  WK( L + I ) = ZERO
                  K = K + NINVR

!  CHECK TO SEE IF ANY OF THE COLUMNS BELONG TO DUPLICATED VARIABLES.

                  II = IELVAR( IS + I )
                  DO 290 J = 1, I - 1
                     IF ( IELVAR( IS + J ) == II ) GO TO 300
  290             CONTINUE
                  GO TO 320

!  AMALGAMATE COLUMNS FROM DUPLICATE VARIABLES.

  300             CONTINUE
                  KK = LSWTRA + LWFREE + ( J - 1 ) * NINVR - 1
                  LL = K - NINVR - 1
                  DO 310 JJ = 1, NINVR
                     WK( KK + JJ ) = WK( KK + JJ ) + WK( LL + JJ )
                     WK( LL + JJ ) = ZERO
  310             CONTINUE
  320          CONTINUE

!  COMPARE THIS TRANSFORMATION MATRIX WITH PREVIOUS ONES.

               DO 340 I = 1, NTYPE
                  IF ( IWK( LSIWTR + IWK( LSSIWT + I ) ) /= NINVR &
                       .OR. IWK( LSIWTR + IWK( LSSIWT + I ) + 1 ) &
                       /= NELVR ) GO TO 340
                  DO 330 J = 0, NINVR * NELVR - 1
                     IF ( WK( LSWTRA + LWFREE + J ) /= WK( &
                          LSWTRA + IWK( LSSWTR + I ) + J ) ) GO TO 340
  330             CONTINUE

!  THE TRANSFORMATION IS AN EXISTING ONE. RECORD WHICH ONE.

                  IWK( LSTYPE + IEL ) = I
                  GO TO 350
  340          CONTINUE

!  ENSURE THAT THERE IS SUFFICIENT ROOM.

               IF ( LIWFRE + 2 + NINVR + NELVR > LIWK ) THEN
                  INFORM = 4
                  WRITE( IOUT, 2030 ) LIWFRE + 2 + NINVR + NELVR - LIWK
                  RETURN
               END IF
               IF ( LWFREE + NINVR * NELVR > LWK ) THEN
                  INFORM = 5
                  WRITE( IOUT, 2040 ) LWFREE + NINVR * NELVR - LWK
                  RETURN
               END IF

!  THE TRANSFORMATION DEFINES A NEW TYPE. RECORD ITS DETAILS.

               NTYPE = NTYPE + 1
               IWK( LSTYPE + IEL ) = NTYPE
               IWK( LSSIWT + NTYPE ) = LIWFRE
               IWK( LSIWTR + LIWFRE ) = NINVR
               IWK( LSIWTR + LIWFRE + 1 ) = NELVR
               IWK( LSSWTR + NTYPE ) = LWFREE
               LIWFRE = LIWFRE + 2 + NINVR + NELVR
               LWFREE = LWFREE + NINVR * NELVR
            ELSE
              IWK( LSTYPE + IEL ) = 0
            END IF
  350    CONTINUE

!  FOR EACH TYPE OF ELEMENT WITH INTERNAL VARIABLES:

         DO 360 I = 1, NTYPE
            LIWFRE = IWK( LSSIWT + I )
            LWFREE = IWK( LSSWTR + I )
            NINVR = IWK( LSIWTR + LIWFRE )

!  FACTORIZE W. USE GAUSSIAN ELIMINATION WITH COMPLETE PIVOTING.
!  DETERMINE THE "MOST INDEPENDENT" SET OF COLUMNS OF W.

      CALL DGELIM( NINVR, IWK( LSIWTR + LIWFRE + 1 ), &
                         IWK( LSIWTR + LIWFRE + 2 ), &
                         IWK( LSIWTR + LIWFRE + NINVR + 2 ), &
                         WK ( LSWTRA + LWFREE ) )
  360    CONTINUE

!  COMPRESS THE DATA STRUCTURES TO REMOVE REDUNDANT INFORMATION.

         IF ( NTYPE < NEL ) THEN
            K = LSSWTR + NTYPE

!  COMPRESS INTEGER DATA.

            DO 370 I = 1, NTYPE
               IWK( K + I ) = IWK( LSSIWT + I )
  370       CONTINUE
            LSSIWT = K
         END IF
         K = LSSIWT + NTYPE
         LNIWTR = 0
         LNWTRA = 0
         DO 400 I = 1, NTYPE
            LIWFRO = IWK( LSSIWT + I ) - 1
            NINVR = IWK( LSIWTR + LIWFRO + 1 )
            DO 380 J = 1, 2 * NINVR + 2
               IWK( K + LNIWTR + J ) = IWK( LSIWTR + LIWFRO + J )
  380       CONTINUE
            IWK( LSSIWT + I ) = LNIWTR + 1
            LNIWTR = LNIWTR + 2 + 2 * NINVR

!  COMPRESS REAL DATA.

            LWFREO = IWK( LSSWTR + I ) - 1
            DO 390 J = 1, NINVR * NINVR
               WK( LSWTRA + LNWTRA + J ) = WK( LSWTRA + LWFREO + J )
  390       CONTINUE
            IWK( LSSWTR + I ) = LNWTRA + 1
            LNWTRA = LNWTRA + NINVR * NINVR
  400    CONTINUE

!  RECORD THE LENGTHS OF THE PARTITIONS OF THE WORKSPACE USED.

         LSIWTR = K
         LWKSTR = LSWTRA + LNWTRA

! ---------------------------------------------------------------------
!  THE LIST OF VARIABLES IS ALLOCATED TO NSETS DISJOINTS SETS.
!  VARIABLE I OCCURS IN SET IWK( LSISET + I ).
! ---------------------------------------------------------------------

         LSISET = LSIWTR + LNIWTR
         LSSVSE = LSISET + N
         LSEND = LSSVSE + N + 1
         IF ( LIWK < LSEND + N ) THEN
            WRITE( IOUT, 2030 ) LSEND + N - LIWK
            INFORM = 4
            RETURN
         END IF

!  ASSIGN INITIAL SET NUMBERS TO EACH VARIABLE.

         NSETS = 0
!DIR$    IVDEP
         DO 410 I = 1, N
            IWK( LSISET + I ) = N
  410    CONTINUE

!  USE THE CURTIS-POWELL-REID ALGORITHM TO DETERMINE WHICH SET EACH
!  VARIABLE BELONGS TO. LOOP OVER THE VARIABLES.

         DO 500 I = 1, N

!  LOOP OVER THE ELEMENTS WHICH USE VARIABLE I.
!  THE ELEMENTS ARE OBTAINED FROM A LINKED-LIST.

            VRUSED = .FALSE.
            IPT = IWK( LSPTRS + I )
            IF ( IPT >= 0 ) THEN
               IELL = IWK( LSELTS + I )
  420          CONTINUE
               IEL = IELING( IELL )
               ITYPE = IWK( LSTYPE + IEL )
!              WRITE( 6, * ) ' ELEMENT ', IEL

!  CHECK THAT THE VARIABLE BELONGS TO THE "INDEPENDENCE" SET OF
!  ELEMENTS WITH INTERNAL VARIABLES.

               IF ( ITYPE > 0 ) THEN
                  LIWFRE = IWK( LSSIWT + ITYPE )
                  NINVR = IWK( LSIWTR + LIWFRE )
                  DO 430 J = 1, NINVR
                     K = J - 1
                     L = IWK( LSIWTR + LIWFRE + NINVR + 1 + J ) - 1
                     IF ( I == IELVAR( ISTAEV( IEL ) + L ) ) &
                        GO TO 440
  430             CONTINUE
                  GO TO 450
  440             CONTINUE
               END IF
               VRUSED = .TRUE.
  450          CONTINUE

!  LOOP OVER THE COMPLETE LIST OF VARIABLES USED BY ELEMENT IEL.

!DIR$ IVDEP
               DO 460 J = ISTAEV( IEL ), ISTAEV( IEL + 1 ) - 1

!  IF VARIABLE IV IS USED, FLAG THE SET THAT CONTAINS IT.

                  IWK( LSEND + IWK( LSISET + IELVAR( J ) ) ) = 1
  460          CONTINUE

!  CHECK THE LINK-LIST TO SEE IF FURTHER ELEMENTS USE THE VARIABLE.

               IF ( IPT > 0 ) THEN
                  IELL = IWK( LSELTS + IPT )
                  IPT = IWK( LSPTRS + IPT )
                  GO TO 420
               END IF
            END IF

!  SEE IF THE VARIABLE MAY BE PLACED IN THE FIRST NSETS SETS.

            IF ( VRUSED ) THEN
               DO 470 J = 1, NSETS
                  IF ( IWK( LSEND + J ) == 0 ) GO TO 480
                  IWK( LSEND + J ) = 0
  470          CONTINUE

!  THE VARIABLE NEEDS A NEW SET.

               NSETS = NSETS + 1
               J = NSETS

!  THE VARIABLE WILL BE PLACED IN SET J.

  480          CONTINUE
               IWK( LSISET + I ) = J

!  RESET THE FLAGS TO ZERO.

!DIR$ IVDEP
               DO 490 K = J, NSETS
                  IWK( LSEND + K ) = 0
  490          CONTINUE
            ELSE

!  THE VARIABLE IS NOT TO BE USED.

               IWK( LSISET + I ) =  N
            END IF
  500    CONTINUE

!  CHECK THAT THERE IS AT LEAST ONE SET.

         IF ( NSETS /= 0 ) THEN

!  PRINT OUTPUT.

!DIR$ IVDEP
            DO 510 I = 1, N
               IWK( LSISET + I ) = MIN( IWK( LSISET + I ), NSETS + 1 )
!              WRITE( 6, * ) ' VARIABLE ', I, ' SET ',
!    *                       IWK( LSISET + I )
  510       CONTINUE

! ---------------------------------------------------------------------
!  OBTAIN A LIST, IWK(LSEND), OF THE VARIABLES CORRESPONDING TO EACH SET.
! ---------------------------------------------------------------------

!  CLEAR IWK( LSSVSE ).

!DIR$ IVDEP
            DO 520 J = 2, NSETS + 2
              IWK( LSSVSE + J ) = 0
  520       CONTINUE

!  COUNT THE NUMBER OF ELEMENTS IN EACH SET AND STORE IN IWK( LSSVSE ).
!  NEGATE THE SET NUMBERS IN IWK( LSISET ), SO THAT THEY ARE FLAGGED
!  AS IWK( LSISET ) IS GRADUALLY OVERWRITTEN BY VARIABLE INDICES.

            DO 530 K = 1, N
               J = IWK( LSISET + K )
               IWK( LSISET + K ) = - J
               IWK( LSSVSE + J + 1 ) = IWK( LSSVSE + J + 1 ) + 1
  530       CONTINUE

!  COMPUTE THE STARTING ADDRESSES FOR EACH SET WITHIN IWK( LSISET ).

            IWK( LSSVSE + 1 ) = 1
            DO 540 J = 2, NSETS + 2
               IWK( LSSVSE + J ) = IWK( LSSVSE + J ) + &
                                   IWK( LSSVSE + J - 1 )
  540       CONTINUE

!  STORE IN IWK( LSEND ) THE VARIABLE WHOSE SET NUMBER
!  IS THE IWK( LSSVSE + J )-TH ENTRY OF IWK( LSEND ).

            ISOFAR = 0
            DO 570 J = 1, NSETS + 1
               ISTARJ = IWK( LSSVSE + J )
               DO 550 IVARP1 = ISOFAR + 1, N
                  IF ( ISTARJ < IVARP1 ) GO TO 560
  550          CONTINUE
               IVARP1 = N + 1
  560          CONTINUE
               ISOFAR = IVARP1 - 1
               IWK( LSEND + J ) = ISOFAR
  570       CONTINUE

!  REORDER THE ELEMENTS INTO SET ORDER.
!  FILL IN EACH SET FROM THE FRONT. AS A NEW ENTRY IS PLACED
!  IN SET K INCREASE THE POINTER IWK( LSSVSE + K ) BY ONE AND FIND
!  THE NEW VARIABLE, IWK( LSEND + K ), THAT CORRESPONDS TO THE SET NOW
!  POINTED TO BY IWK( LSSVSE + K ).

            DO 660 J = 1, NSETS + 1

!  DETERMINE THE NEXT UNPLACED ENTRY, IWK( LSSVSE ), IN IWK( LSISET ).

  610          CONTINUE
               ISTRT = IWK( LSSVSE + J )

!  SEE IF ALL THE ELEMENTS IN SET J HAVE BEEN ASSIGNED.

               IF ( ISTRT == IWK( LSSVSE + J + 1 ) ) GO TO 660
               IF ( IWK( LSISET + ISTRT ) > 0 ) GO TO 660

!  EXTRACT THE VARIABLE AND SET NUMBERS OF THE STARTING ELEMENT.

               IVAR = IWK( LSEND + J )
               JSET = - IWK( LSISET + ISTRT )

!  MOVE ELEMENTS IN A CYCLE, ENDING BACK AT SET J.

               DO 640 K = ISTRT, N

!  FIND THE FIRST EMPTY LOCATION IN SET JSET IN IWK( LSEND )

                  INEXT = IWK( LSSVSE + JSET )

!  EXTRACT THE VARIABLE INDEX OF THE NEXT ELEMENT.

                  NEWVAR = IWK( LSEND + JSET )

!  UPDATE IWK( LSSVSE + JSET ), FIND THE NEW VARIABLE INDEX AND STORE
!  IT IN IWK( LSEND + JSET ).

                  ISTARJ = INEXT + 1
                  IWK( LSSVSE + JSET ) = ISTARJ
                  DO 620 IVARP1 = NEWVAR + 1, N
                     IF ( ISTARJ < IVARP1 ) GO TO 630
  620             CONTINUE
                  IVARP1 = N + 1
  630             CONTINUE
                  IWK( LSEND + JSET ) = IVARP1 - 1

!  IF THE ENTRY BELONGS IN THE J-TH SET, THE CYCLE IS COMPLETE.

                  IF ( JSET == J ) GO TO 650

!  EXTRACT THE NUMBER OF THE SET OF THE NEXT ELEMENT.

                  NEWSET = - IWK( LSISET + INEXT )

!  STORE THE VARIABLE INDEX OF THE CURRENT ELEMENT.

                  IWK( LSISET + INEXT ) = IVAR

!  MAKE THE NEXT ELEMENT INTO THE CURRENT ONE.

                  IVAR = NEWVAR
                  JSET = NEWSET
  640          CONTINUE

!  THE CYCLE IS COMPLETE.

  650          CONTINUE

!  STORE THE VARIABLE INDEX OF THE STARTING ELEMENT.

               IWK( LSISET + ISTRT ) = IVAR
               GO TO 610
  660       CONTINUE

!  REVISE IWK( LSSVSE ) TO POINT TO THE START OF EACH SET.

            DO 670 J = NSETS + 1, 2, - 1
               IWK( LSSVSE + J ) = IWK( LSSVSE + J - 1 )
  670       CONTINUE
            IWK( LSSVSE + 1 ) = 1
         END IF
!        DO 671 I = 1, NSETS
!           WRITE( 6, * ) ' SET ', I, ' VARIABLES ',
!    * ( IWK( LSISET + J ), J = IWK( LSSVSE + I ),
!    *         IWK( LSSVSE + I + 1 ) - 1 )
! 671    CONTINUE
      ELSE

!  EXACT GRADIENTS ARE USED. NO FURTHER PARTITIONING OF THE WORKSPACE
!  IS NEEDED.

         LSTYPE = LSEND
         LSSWTR = LSTYPE
         LSSIWT = LSSWTR
         LSIWTR = LSSIWT
         LSISET = LSIWTR
         LSSVSE = LSISET
         LSWTRA = LWKSTR
      END IF

!  SET THE LENGTH OF THE REMAINING PARTITIONS OF THE WORKSPACE FOR
!  ARRAY BOUND CHECKING IN CALLS TO OTHER SUBPROGRAMS.

      LNTYPE = MAX( 1, LSSWTR - LSTYPE )
      LNSWTR = MAX( 1, LSSIWT - LSSWTR )
      LNSIWT = MAX( 1, LSIWTR - LSSIWT )
      LNIWTR = MAX( 1, LSISET - LSIWTR )
      LNISET = MAX( 1, LSSVSE - LSISET )
      LNSVSE = MAX( 1, LSEND - LSSVSE )
      LNWTRA = MAX( 1, LWKSTR - LSWTRA )

!  RECORD THE LENGTHS OF THE REMAINING INTEGER AND REAL WORKSPACE.

      LIWK2 = LIWK - LSEND
      LWK2 = LWK - LWKSTR

! -- SET THE STARTING ADDRESSES FOR THE PARTITIONS WITHIN FUVALS. --

!  A FULL DESCRIPTION OF THE PARTITIONS OF FUVALS IS GIVEN IN THE
!  THE INTRODUCTORY COMMENTS TO SUBROUTINE SBMIN.

      LFXI = 0
      LGXI = LFXI + NEL
      LHXI = INTVAR( NEL1 ) - 1
      LGGFX = LGGFX - 1
      LDX = LGGFX + N
      LGRJAC = LDX + N
      LEND = LGRJAC + NVARGP

!  PRINT ALL OF THE STARTING ADDRESSES FOR THE WORKSPACE ARRAY
!  PARTITIONS.

      IF ( IPRINT >= 3 ) THEN
         WRITE( IOUT, 2000 ) &
           LFXI, LGXI, LHXI, LGGFX, LDX, LGRJAC, LEND, LFUVAL
         WRITE( IOUT, 2010 ) LSPTRS, LSELTS, LINDEX, &
                             LSWKSP, LIUSED, LFREEC, LNNONZ, LNONZ2, &
                             LSYMMD, LSYMMH, LSLGRP, LSTAJC, &
                             LSTAGV, LSVGRP, LGCOLJ, LVALJR, &
                             LSTYPE, LSSWTR, LSSIWT, LSIWTR, LSISET, &
                             LSSVSE, LSEND, LIWK
         WRITE( IOUT, 2020 ) LQGRAD, LBREAK, LP,     LXCP, LX0, LGX0, &
                             LDELTX, LBND, LSWTRA, LWKSTR, LWK
      END IF

!  CHECK THAT THE ARRAY FUVALS HAS SUFFICIENT ROOM FOR THE CALCULATION.

      IF ( LEND > LFUVAL ) THEN
         WRITE( IOUT, 2050 ) LEND - LFUVAL
         INFORM = 5
         RETURN
      END IF

!  SET THE LENGTH OF EACH PARTITION OF THE REAL WORKSPACE ARRAY
!  FUVALS FOR ARRAY BOUND CHECKING IN CALLS TO OTHER SUBPROGRAMS.

      LNFXI = MAX( 1, LGXI - LFXI )
      LNGXI = MAX( 1, LHXI - LGXI )
      LNGUVL = MAX( 1, LHXI - LFXI )
      LNHXI = MAX( 1, LGGFX - LHXI )
      LNHUVL = MAX( 1, LGGFX - LFXI )
      LNGGFX = MAX( 1, LDX - LGGFX )
      LNDX = MAX( 1, LGRJAC - LDX )
      LNGRJC = MAX( 1, LEND - LGRJAC )
      MAXSIN = MAX( 1, MAXSIN )
      MAXSEL = MAX( 1, MAXSEL )
      INFORM = 0

!  NON-EXECUTABLE STATEMENTS.

 2000 FORMAT( /, ' Starting addresses for the partitions of FUVALS ', &
              /, ' ----------------------------------------------- ', &
             //, '   LFXI   LGXI   LHXI  LGGFX ', &
                 '   LDX LGRJAC   LEND   LFUVAL ', /, 7I7, I9 )
 2010 FORMAT( /, ' Starting addresses for partitions of IWK ', &
              /, ' ---------------------------------------- ', //, &
        ' LSPTRS LSELTS LINDEX LSWKSP LIUSED LFREEC LNNONZ LNONZ2  ...', &
         /, 8I7, //, &
         ' ...... LSYMMD LSYMMH LSLGRP LSTAJC LSTAGV LSVGRP LGCOLJ ...', &
         /, 7X, 7I7, //, &
        ' ...... LVALJR LSTYPE LSSWTR LSSIWT LSIWTR LSISET LSSVSE ... ', &
         /, 7X, 7I7, //, &
         ' ......  LSEND     LIWK ', &
         /, 7X, I7, I9 )
 2020 FORMAT( /, ' Starting addresses for partitions of WK ', &
              /, ' --------------------------------------- ', //, &
         '   LQGRAD   LBREAK       LP     LXCP      LX0     LGX0 ... ', &
         /, 6I9, //, &
         '   ......   LDELTX     LBND   LSWTRA   LWKSTR      LWK ', &
         /, 9X, 5I9 )
 2030 FORMAT( /, ' INITW: The size of array IWK must be increased', &
                 ' by at least ', I12 )
 2040 FORMAT( /, ' INITW: The size of array WK must be increased', &
                 ' by at least ', I8 )
 2050 FORMAT( /, ' INITW: The size of array FUVALS must be increased', &
                 ' by at least ', I8 )
      RETURN

!  END OF SUBROUTINE INITW.

      END
